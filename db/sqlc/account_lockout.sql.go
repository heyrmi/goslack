// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: account_lockout.sql

package db

import (
	"context"
	"database/sql"
)

const createAccountLockout = `-- name: CreateAccountLockout :one
INSERT INTO account_lockouts (user_id, failed_attempts, last_failed_attempt)
VALUES ($1, 1, now())
RETURNING id, user_id, failed_attempts, locked_until, last_failed_attempt, created_at, updated_at
`

func (q *Queries) CreateAccountLockout(ctx context.Context, userID int64) (AccountLockout, error) {
	row := q.db.QueryRowContext(ctx, createAccountLockout, userID)
	var i AccountLockout
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FailedAttempts,
		&i.LockedUntil,
		&i.LastFailedAttempt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAccountLockout = `-- name: GetAccountLockout :one
SELECT id, user_id, failed_attempts, locked_until, last_failed_attempt, created_at, updated_at FROM account_lockouts WHERE user_id = $1
`

func (q *Queries) GetAccountLockout(ctx context.Context, userID int64) (AccountLockout, error) {
	row := q.db.QueryRowContext(ctx, getAccountLockout, userID)
	var i AccountLockout
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FailedAttempts,
		&i.LockedUntil,
		&i.LastFailedAttempt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementFailedAttempts = `-- name: IncrementFailedAttempts :one
UPDATE account_lockouts 
SET failed_attempts = failed_attempts + 1, 
    last_failed_attempt = now(),
    updated_at = now()
WHERE user_id = $1 
RETURNING id, user_id, failed_attempts, locked_until, last_failed_attempt, created_at, updated_at
`

func (q *Queries) IncrementFailedAttempts(ctx context.Context, userID int64) (AccountLockout, error) {
	row := q.db.QueryRowContext(ctx, incrementFailedAttempts, userID)
	var i AccountLockout
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FailedAttempts,
		&i.LockedUntil,
		&i.LastFailedAttempt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const isAccountLocked = `-- name: IsAccountLocked :one
SELECT locked_until IS NOT NULL AND locked_until > now() as is_locked
FROM account_lockouts 
WHERE user_id = $1
`

func (q *Queries) IsAccountLocked(ctx context.Context, userID int64) (sql.NullBool, error) {
	row := q.db.QueryRowContext(ctx, isAccountLocked, userID)
	var is_locked sql.NullBool
	err := row.Scan(&is_locked)
	return is_locked, err
}

const lockAccount = `-- name: LockAccount :exec
UPDATE account_lockouts 
SET locked_until = $2, updated_at = now()
WHERE user_id = $1
`

type LockAccountParams struct {
	UserID      int64        `json:"user_id"`
	LockedUntil sql.NullTime `json:"locked_until"`
}

func (q *Queries) LockAccount(ctx context.Context, arg LockAccountParams) error {
	_, err := q.db.ExecContext(ctx, lockAccount, arg.UserID, arg.LockedUntil)
	return err
}

const resetFailedAttempts = `-- name: ResetFailedAttempts :exec
UPDATE account_lockouts 
SET failed_attempts = 0, 
    last_failed_attempt = NULL,
    updated_at = now()
WHERE user_id = $1
`

func (q *Queries) ResetFailedAttempts(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, resetFailedAttempts, userID)
	return err
}

const unlockAccount = `-- name: UnlockAccount :exec
UPDATE account_lockouts 
SET locked_until = NULL, 
    failed_attempts = 0, 
    updated_at = now()
WHERE user_id = $1
`

func (q *Queries) UnlockAccount(ctx context.Context, userID int64) error {
	_, err := q.db.ExecContext(ctx, unlockAccount, userID)
	return err
}

const unlockExpiredAccounts = `-- name: UnlockExpiredAccounts :exec
UPDATE account_lockouts 
SET locked_until = NULL, failed_attempts = 0, updated_at = now()
WHERE locked_until IS NOT NULL AND locked_until < now()
`

func (q *Queries) UnlockExpiredAccounts(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, unlockExpiredAccounts)
	return err
}
