// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: message_search.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const searchMessages = `-- name: SearchMessages :many
SELECT m.id, m.workspace_id, m.channel_id, m.sender_id, m.receiver_id, 
       m.content, m.message_type, m.thread_id, m.created_at, m.content_type,
       u.first_name, u.last_name,
       c.name as channel_name,
       ts_rank(msi.content_vector, plainto_tsquery($4)) as rank
FROM message_search_index msi
JOIN messages m ON msi.message_id = m.id
JOIN users u ON m.sender_id = u.id
LEFT JOIN channels c ON m.channel_id = c.id
WHERE msi.workspace_id = $1
  AND ($2::BIGINT IS NULL OR msi.channel_id = $2)
  AND ($3::BIGINT IS NULL OR msi.user_id = $3)
  AND msi.content_vector @@ plainto_tsquery($4)
  AND m.deleted_at IS NULL
ORDER BY rank DESC, m.created_at DESC
LIMIT $5 OFFSET $6
`

type SearchMessagesParams struct {
	WorkspaceID    int64  `json:"workspace_id"`
	Column2        int64  `json:"column_2"`
	Column3        int64  `json:"column_3"`
	PlaintoTsquery string `json:"plainto_tsquery"`
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
}

type SearchMessagesRow struct {
	ID          int64          `json:"id"`
	WorkspaceID int64          `json:"workspace_id"`
	ChannelID   sql.NullInt64  `json:"channel_id"`
	SenderID    int64          `json:"sender_id"`
	ReceiverID  sql.NullInt64  `json:"receiver_id"`
	Content     string         `json:"content"`
	MessageType string         `json:"message_type"`
	ThreadID    sql.NullInt64  `json:"thread_id"`
	CreatedAt   time.Time      `json:"created_at"`
	ContentType string         `json:"content_type"`
	FirstName   string         `json:"first_name"`
	LastName    string         `json:"last_name"`
	ChannelName sql.NullString `json:"channel_name"`
	Rank        float32        `json:"rank"`
}

func (q *Queries) SearchMessages(ctx context.Context, arg SearchMessagesParams) ([]SearchMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchMessages,
		arg.WorkspaceID,
		arg.Column2,
		arg.Column3,
		arg.PlaintoTsquery,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchMessagesRow{}
	for rows.Next() {
		var i SearchMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ChannelID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Content,
			&i.MessageType,
			&i.ThreadID,
			&i.CreatedAt,
			&i.ContentType,
			&i.FirstName,
			&i.LastName,
			&i.ChannelName,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMessagesInThread = `-- name: SearchMessagesInThread :many
SELECT m.id, m.workspace_id, m.channel_id, m.sender_id, m.receiver_id, 
       m.content, m.message_type, m.thread_id, m.created_at, m.content_type,
       u.first_name, u.last_name,
       ts_rank(msi.content_vector, plainto_tsquery($3)) as rank
FROM message_search_index msi
JOIN messages m ON msi.message_id = m.id
JOIN users u ON m.sender_id = u.id
WHERE (m.id = $1 OR m.thread_id = $1)
  AND msi.workspace_id = $2
  AND msi.content_vector @@ plainto_tsquery($3)
  AND m.deleted_at IS NULL
ORDER BY rank DESC, m.created_at ASC
LIMIT $4 OFFSET $5
`

type SearchMessagesInThreadParams struct {
	ID             int64  `json:"id"`
	WorkspaceID    int64  `json:"workspace_id"`
	PlaintoTsquery string `json:"plainto_tsquery"`
	Limit          int32  `json:"limit"`
	Offset         int32  `json:"offset"`
}

type SearchMessagesInThreadRow struct {
	ID          int64         `json:"id"`
	WorkspaceID int64         `json:"workspace_id"`
	ChannelID   sql.NullInt64 `json:"channel_id"`
	SenderID    int64         `json:"sender_id"`
	ReceiverID  sql.NullInt64 `json:"receiver_id"`
	Content     string        `json:"content"`
	MessageType string        `json:"message_type"`
	ThreadID    sql.NullInt64 `json:"thread_id"`
	CreatedAt   time.Time     `json:"created_at"`
	ContentType string        `json:"content_type"`
	FirstName   string        `json:"first_name"`
	LastName    string        `json:"last_name"`
	Rank        float32       `json:"rank"`
}

func (q *Queries) SearchMessagesInThread(ctx context.Context, arg SearchMessagesInThreadParams) ([]SearchMessagesInThreadRow, error) {
	rows, err := q.db.QueryContext(ctx, searchMessagesInThread,
		arg.ID,
		arg.WorkspaceID,
		arg.PlaintoTsquery,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SearchMessagesInThreadRow{}
	for rows.Next() {
		var i SearchMessagesInThreadRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ChannelID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Content,
			&i.MessageType,
			&i.ThreadID,
			&i.CreatedAt,
			&i.ContentType,
			&i.FirstName,
			&i.LastName,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
