// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: message.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const checkMessageAuthor = `-- name: CheckMessageAuthor :one
SELECT sender_id FROM messages
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) CheckMessageAuthor(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkMessageAuthor, id)
	var sender_id int64
	err := row.Scan(&sender_id)
	return sender_id, err
}

const createChannelMessage = `-- name: CreateChannelMessage :one
INSERT INTO messages (
    workspace_id,
    channel_id,
    sender_id,
    content,
    message_type
) VALUES (
    $1, $2, $3, $4, 'channel'
)
RETURNING id, workspace_id, channel_id, sender_id, receiver_id, content, message_type, thread_id, edited_at, deleted_at, created_at
`

type CreateChannelMessageParams struct {
	WorkspaceID int64         `json:"workspace_id"`
	ChannelID   sql.NullInt64 `json:"channel_id"`
	SenderID    int64         `json:"sender_id"`
	Content     string        `json:"content"`
}

func (q *Queries) CreateChannelMessage(ctx context.Context, arg CreateChannelMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createChannelMessage,
		arg.WorkspaceID,
		arg.ChannelID,
		arg.SenderID,
		arg.Content,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ChannelID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Content,
		&i.MessageType,
		&i.ThreadID,
		&i.EditedAt,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createDirectMessage = `-- name: CreateDirectMessage :one
INSERT INTO messages (
    workspace_id,
    sender_id,
    receiver_id,
    content,
    message_type
) VALUES (
    $1, $2, $3, $4, 'direct'
)
RETURNING id, workspace_id, channel_id, sender_id, receiver_id, content, message_type, thread_id, edited_at, deleted_at, created_at
`

type CreateDirectMessageParams struct {
	WorkspaceID int64         `json:"workspace_id"`
	SenderID    int64         `json:"sender_id"`
	ReceiverID  sql.NullInt64 `json:"receiver_id"`
	Content     string        `json:"content"`
}

func (q *Queries) CreateDirectMessage(ctx context.Context, arg CreateDirectMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createDirectMessage,
		arg.WorkspaceID,
		arg.SenderID,
		arg.ReceiverID,
		arg.Content,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ChannelID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Content,
		&i.MessageType,
		&i.ThreadID,
		&i.EditedAt,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getChannelMessages = `-- name: GetChannelMessages :many
SELECT 
    m.id, m.workspace_id, m.channel_id, m.sender_id, m.receiver_id, m.content, m.message_type, m.thread_id, m.edited_at, m.deleted_at, m.created_at,
    u.first_name as sender_first_name,
    u.last_name as sender_last_name,
    u.email as sender_email
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.channel_id = $1 
    AND m.workspace_id = $2 
    AND m.deleted_at IS NULL
ORDER BY m.created_at DESC
LIMIT $3
OFFSET $4
`

type GetChannelMessagesParams struct {
	ChannelID   sql.NullInt64 `json:"channel_id"`
	WorkspaceID int64         `json:"workspace_id"`
	Limit       int32         `json:"limit"`
	Offset      int32         `json:"offset"`
}

type GetChannelMessagesRow struct {
	ID              int64         `json:"id"`
	WorkspaceID     int64         `json:"workspace_id"`
	ChannelID       sql.NullInt64 `json:"channel_id"`
	SenderID        int64         `json:"sender_id"`
	ReceiverID      sql.NullInt64 `json:"receiver_id"`
	Content         string        `json:"content"`
	MessageType     string        `json:"message_type"`
	ThreadID        sql.NullInt64 `json:"thread_id"`
	EditedAt        sql.NullTime  `json:"edited_at"`
	DeletedAt       sql.NullTime  `json:"deleted_at"`
	CreatedAt       time.Time     `json:"created_at"`
	SenderFirstName string        `json:"sender_first_name"`
	SenderLastName  string        `json:"sender_last_name"`
	SenderEmail     string        `json:"sender_email"`
}

func (q *Queries) GetChannelMessages(ctx context.Context, arg GetChannelMessagesParams) ([]GetChannelMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getChannelMessages,
		arg.ChannelID,
		arg.WorkspaceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChannelMessagesRow{}
	for rows.Next() {
		var i GetChannelMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ChannelID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Content,
			&i.MessageType,
			&i.ThreadID,
			&i.EditedAt,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.SenderEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDirectMessagesBetweenUsers = `-- name: GetDirectMessagesBetweenUsers :many
SELECT 
    m.id, m.workspace_id, m.channel_id, m.sender_id, m.receiver_id, m.content, m.message_type, m.thread_id, m.edited_at, m.deleted_at, m.created_at,
    u.first_name as sender_first_name,
    u.last_name as sender_last_name,
    u.email as sender_email
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.workspace_id = $1 
    AND m.message_type = 'direct'
    AND m.deleted_at IS NULL
    AND (
        (m.sender_id = $2 AND m.receiver_id = $3) OR
        (m.sender_id = $3 AND m.receiver_id = $2)
    )
ORDER BY m.created_at DESC
LIMIT $4
OFFSET $5
`

type GetDirectMessagesBetweenUsersParams struct {
	WorkspaceID int64         `json:"workspace_id"`
	SenderID    int64         `json:"sender_id"`
	ReceiverID  sql.NullInt64 `json:"receiver_id"`
	Limit       int32         `json:"limit"`
	Offset      int32         `json:"offset"`
}

type GetDirectMessagesBetweenUsersRow struct {
	ID              int64         `json:"id"`
	WorkspaceID     int64         `json:"workspace_id"`
	ChannelID       sql.NullInt64 `json:"channel_id"`
	SenderID        int64         `json:"sender_id"`
	ReceiverID      sql.NullInt64 `json:"receiver_id"`
	Content         string        `json:"content"`
	MessageType     string        `json:"message_type"`
	ThreadID        sql.NullInt64 `json:"thread_id"`
	EditedAt        sql.NullTime  `json:"edited_at"`
	DeletedAt       sql.NullTime  `json:"deleted_at"`
	CreatedAt       time.Time     `json:"created_at"`
	SenderFirstName string        `json:"sender_first_name"`
	SenderLastName  string        `json:"sender_last_name"`
	SenderEmail     string        `json:"sender_email"`
}

func (q *Queries) GetDirectMessagesBetweenUsers(ctx context.Context, arg GetDirectMessagesBetweenUsersParams) ([]GetDirectMessagesBetweenUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getDirectMessagesBetweenUsers,
		arg.WorkspaceID,
		arg.SenderID,
		arg.ReceiverID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDirectMessagesBetweenUsersRow{}
	for rows.Next() {
		var i GetDirectMessagesBetweenUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ChannelID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Content,
			&i.MessageType,
			&i.ThreadID,
			&i.EditedAt,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.SenderEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT 
    m.id, m.workspace_id, m.channel_id, m.sender_id, m.receiver_id, m.content, m.message_type, m.thread_id, m.edited_at, m.deleted_at, m.created_at,
    u.first_name as sender_first_name,
    u.last_name as sender_last_name,
    u.email as sender_email
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.id = $1 AND m.deleted_at IS NULL
`

type GetMessageByIDRow struct {
	ID              int64         `json:"id"`
	WorkspaceID     int64         `json:"workspace_id"`
	ChannelID       sql.NullInt64 `json:"channel_id"`
	SenderID        int64         `json:"sender_id"`
	ReceiverID      sql.NullInt64 `json:"receiver_id"`
	Content         string        `json:"content"`
	MessageType     string        `json:"message_type"`
	ThreadID        sql.NullInt64 `json:"thread_id"`
	EditedAt        sql.NullTime  `json:"edited_at"`
	DeletedAt       sql.NullTime  `json:"deleted_at"`
	CreatedAt       time.Time     `json:"created_at"`
	SenderFirstName string        `json:"sender_first_name"`
	SenderLastName  string        `json:"sender_last_name"`
	SenderEmail     string        `json:"sender_email"`
}

func (q *Queries) GetMessageByID(ctx context.Context, id int64) (GetMessageByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getMessageByID, id)
	var i GetMessageByIDRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ChannelID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Content,
		&i.MessageType,
		&i.ThreadID,
		&i.EditedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.SenderFirstName,
		&i.SenderLastName,
		&i.SenderEmail,
	)
	return i, err
}

const getRecentWorkspaceMessages = `-- name: GetRecentWorkspaceMessages :many
SELECT 
    m.id, m.workspace_id, m.channel_id, m.sender_id, m.receiver_id, m.content, m.message_type, m.thread_id, m.edited_at, m.deleted_at, m.created_at,
    u.first_name as sender_first_name,
    u.last_name as sender_last_name,
    u.email as sender_email
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.workspace_id = $1 
    AND m.deleted_at IS NULL
ORDER BY m.created_at DESC
LIMIT $2
OFFSET $3
`

type GetRecentWorkspaceMessagesParams struct {
	WorkspaceID int64 `json:"workspace_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

type GetRecentWorkspaceMessagesRow struct {
	ID              int64         `json:"id"`
	WorkspaceID     int64         `json:"workspace_id"`
	ChannelID       sql.NullInt64 `json:"channel_id"`
	SenderID        int64         `json:"sender_id"`
	ReceiverID      sql.NullInt64 `json:"receiver_id"`
	Content         string        `json:"content"`
	MessageType     string        `json:"message_type"`
	ThreadID        sql.NullInt64 `json:"thread_id"`
	EditedAt        sql.NullTime  `json:"edited_at"`
	DeletedAt       sql.NullTime  `json:"deleted_at"`
	CreatedAt       time.Time     `json:"created_at"`
	SenderFirstName string        `json:"sender_first_name"`
	SenderLastName  string        `json:"sender_last_name"`
	SenderEmail     string        `json:"sender_email"`
}

func (q *Queries) GetRecentWorkspaceMessages(ctx context.Context, arg GetRecentWorkspaceMessagesParams) ([]GetRecentWorkspaceMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentWorkspaceMessages, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentWorkspaceMessagesRow{}
	for rows.Next() {
		var i GetRecentWorkspaceMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ChannelID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Content,
			&i.MessageType,
			&i.ThreadID,
			&i.EditedAt,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.SenderEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteMessage = `-- name: SoftDeleteMessage :exec
UPDATE messages
SET deleted_at = now()
WHERE id = $1
`

func (q *Queries) SoftDeleteMessage(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, softDeleteMessage, id)
	return err
}

const updateMessageContent = `-- name: UpdateMessageContent :one
UPDATE messages
SET 
    content = $2,
    edited_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, workspace_id, channel_id, sender_id, receiver_id, content, message_type, thread_id, edited_at, deleted_at, created_at
`

type UpdateMessageContentParams struct {
	ID      int64  `json:"id"`
	Content string `json:"content"`
}

func (q *Queries) UpdateMessageContent(ctx context.Context, arg UpdateMessageContentParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, updateMessageContent, arg.ID, arg.Content)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ChannelID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Content,
		&i.MessageType,
		&i.ThreadID,
		&i.EditedAt,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}
