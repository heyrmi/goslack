// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: message.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const checkMessageAuthor = `-- name: CheckMessageAuthor :one
SELECT sender_id FROM messages
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) CheckMessageAuthor(ctx context.Context, id int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkMessageAuthor, id)
	var sender_id int64
	err := row.Scan(&sender_id)
	return sender_id, err
}

const createChannelMessage = `-- name: CreateChannelMessage :one
INSERT INTO messages (
    workspace_id,
    channel_id,
    sender_id,
    content,
    content_type,
    message_type
) VALUES (
    $1, $2, $3, $4, $5, 'channel'
)
RETURNING id, workspace_id, channel_id, sender_id, receiver_id, content, message_type, thread_id, edited_at, deleted_at, created_at, content_type, reply_count, last_reply_at
`

type CreateChannelMessageParams struct {
	WorkspaceID int64         `json:"workspace_id"`
	ChannelID   sql.NullInt64 `json:"channel_id"`
	SenderID    int64         `json:"sender_id"`
	Content     string        `json:"content"`
	ContentType string        `json:"content_type"`
}

func (q *Queries) CreateChannelMessage(ctx context.Context, arg CreateChannelMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createChannelMessage,
		arg.WorkspaceID,
		arg.ChannelID,
		arg.SenderID,
		arg.Content,
		arg.ContentType,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ChannelID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Content,
		&i.MessageType,
		&i.ThreadID,
		&i.EditedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.ContentType,
		&i.ReplyCount,
		&i.LastReplyAt,
	)
	return i, err
}

const createDirectMessage = `-- name: CreateDirectMessage :one
INSERT INTO messages (
    workspace_id,
    sender_id,
    receiver_id,
    content,
    content_type,
    message_type
) VALUES (
    $1, $2, $3, $4, $5, 'direct'
)
RETURNING id, workspace_id, channel_id, sender_id, receiver_id, content, message_type, thread_id, edited_at, deleted_at, created_at, content_type, reply_count, last_reply_at
`

type CreateDirectMessageParams struct {
	WorkspaceID int64         `json:"workspace_id"`
	SenderID    int64         `json:"sender_id"`
	ReceiverID  sql.NullInt64 `json:"receiver_id"`
	Content     string        `json:"content"`
	ContentType string        `json:"content_type"`
}

func (q *Queries) CreateDirectMessage(ctx context.Context, arg CreateDirectMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createDirectMessage,
		arg.WorkspaceID,
		arg.SenderID,
		arg.ReceiverID,
		arg.Content,
		arg.ContentType,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ChannelID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Content,
		&i.MessageType,
		&i.ThreadID,
		&i.EditedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.ContentType,
		&i.ReplyCount,
		&i.LastReplyAt,
	)
	return i, err
}

const createThreadReply = `-- name: CreateThreadReply :one
INSERT INTO messages (
    workspace_id,
    channel_id,
    sender_id,
    receiver_id,
    content,
    content_type,
    message_type,
    thread_id
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, workspace_id, channel_id, sender_id, receiver_id, content, message_type, thread_id, edited_at, deleted_at, created_at, content_type, reply_count, last_reply_at
`

type CreateThreadReplyParams struct {
	WorkspaceID int64         `json:"workspace_id"`
	ChannelID   sql.NullInt64 `json:"channel_id"`
	SenderID    int64         `json:"sender_id"`
	ReceiverID  sql.NullInt64 `json:"receiver_id"`
	Content     string        `json:"content"`
	ContentType string        `json:"content_type"`
	MessageType string        `json:"message_type"`
	ThreadID    sql.NullInt64 `json:"thread_id"`
}

func (q *Queries) CreateThreadReply(ctx context.Context, arg CreateThreadReplyParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createThreadReply,
		arg.WorkspaceID,
		arg.ChannelID,
		arg.SenderID,
		arg.ReceiverID,
		arg.Content,
		arg.ContentType,
		arg.MessageType,
		arg.ThreadID,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ChannelID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Content,
		&i.MessageType,
		&i.ThreadID,
		&i.EditedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.ContentType,
		&i.ReplyCount,
		&i.LastReplyAt,
	)
	return i, err
}

const getChannelMessages = `-- name: GetChannelMessages :many
SELECT 
    m.id, m.workspace_id, m.channel_id, m.sender_id, m.receiver_id, m.content, m.message_type, m.thread_id, m.edited_at, m.deleted_at, m.created_at, m.content_type, m.reply_count, m.last_reply_at,
    u.first_name as sender_first_name,
    u.last_name as sender_last_name,
    u.email as sender_email
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.channel_id = $1 
    AND m.workspace_id = $2 
    AND m.deleted_at IS NULL
ORDER BY m.created_at DESC
LIMIT $3
OFFSET $4
`

type GetChannelMessagesParams struct {
	ChannelID   sql.NullInt64 `json:"channel_id"`
	WorkspaceID int64         `json:"workspace_id"`
	Limit       int32         `json:"limit"`
	Offset      int32         `json:"offset"`
}

type GetChannelMessagesRow struct {
	ID              int64         `json:"id"`
	WorkspaceID     int64         `json:"workspace_id"`
	ChannelID       sql.NullInt64 `json:"channel_id"`
	SenderID        int64         `json:"sender_id"`
	ReceiverID      sql.NullInt64 `json:"receiver_id"`
	Content         string        `json:"content"`
	MessageType     string        `json:"message_type"`
	ThreadID        sql.NullInt64 `json:"thread_id"`
	EditedAt        sql.NullTime  `json:"edited_at"`
	DeletedAt       sql.NullTime  `json:"deleted_at"`
	CreatedAt       time.Time     `json:"created_at"`
	ContentType     string        `json:"content_type"`
	ReplyCount      int32         `json:"reply_count"`
	LastReplyAt     sql.NullTime  `json:"last_reply_at"`
	SenderFirstName string        `json:"sender_first_name"`
	SenderLastName  string        `json:"sender_last_name"`
	SenderEmail     string        `json:"sender_email"`
}

func (q *Queries) GetChannelMessages(ctx context.Context, arg GetChannelMessagesParams) ([]GetChannelMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getChannelMessages,
		arg.ChannelID,
		arg.WorkspaceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChannelMessagesRow{}
	for rows.Next() {
		var i GetChannelMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ChannelID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Content,
			&i.MessageType,
			&i.ThreadID,
			&i.EditedAt,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.ContentType,
			&i.ReplyCount,
			&i.LastReplyAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.SenderEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDirectMessagesBetweenUsers = `-- name: GetDirectMessagesBetweenUsers :many
SELECT 
    m.id, m.workspace_id, m.channel_id, m.sender_id, m.receiver_id, m.content, m.message_type, m.thread_id, m.edited_at, m.deleted_at, m.created_at, m.content_type, m.reply_count, m.last_reply_at,
    u.first_name as sender_first_name,
    u.last_name as sender_last_name,
    u.email as sender_email
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.workspace_id = $1 
    AND m.message_type = 'direct'
    AND m.deleted_at IS NULL
    AND (
        (m.sender_id = $2 AND m.receiver_id = $3) OR
        (m.sender_id = $3 AND m.receiver_id = $2)
    )
ORDER BY m.created_at DESC
LIMIT $4
OFFSET $5
`

type GetDirectMessagesBetweenUsersParams struct {
	WorkspaceID int64         `json:"workspace_id"`
	SenderID    int64         `json:"sender_id"`
	ReceiverID  sql.NullInt64 `json:"receiver_id"`
	Limit       int32         `json:"limit"`
	Offset      int32         `json:"offset"`
}

type GetDirectMessagesBetweenUsersRow struct {
	ID              int64         `json:"id"`
	WorkspaceID     int64         `json:"workspace_id"`
	ChannelID       sql.NullInt64 `json:"channel_id"`
	SenderID        int64         `json:"sender_id"`
	ReceiverID      sql.NullInt64 `json:"receiver_id"`
	Content         string        `json:"content"`
	MessageType     string        `json:"message_type"`
	ThreadID        sql.NullInt64 `json:"thread_id"`
	EditedAt        sql.NullTime  `json:"edited_at"`
	DeletedAt       sql.NullTime  `json:"deleted_at"`
	CreatedAt       time.Time     `json:"created_at"`
	ContentType     string        `json:"content_type"`
	ReplyCount      int32         `json:"reply_count"`
	LastReplyAt     sql.NullTime  `json:"last_reply_at"`
	SenderFirstName string        `json:"sender_first_name"`
	SenderLastName  string        `json:"sender_last_name"`
	SenderEmail     string        `json:"sender_email"`
}

func (q *Queries) GetDirectMessagesBetweenUsers(ctx context.Context, arg GetDirectMessagesBetweenUsersParams) ([]GetDirectMessagesBetweenUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getDirectMessagesBetweenUsers,
		arg.WorkspaceID,
		arg.SenderID,
		arg.ReceiverID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDirectMessagesBetweenUsersRow{}
	for rows.Next() {
		var i GetDirectMessagesBetweenUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ChannelID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Content,
			&i.MessageType,
			&i.ThreadID,
			&i.EditedAt,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.ContentType,
			&i.ReplyCount,
			&i.LastReplyAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.SenderEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT 
    m.id, m.workspace_id, m.channel_id, m.sender_id, m.receiver_id, m.content, m.message_type, m.thread_id, m.edited_at, m.deleted_at, m.created_at, m.content_type, m.reply_count, m.last_reply_at,
    u.first_name as sender_first_name,
    u.last_name as sender_last_name,
    u.email as sender_email
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.id = $1 AND m.deleted_at IS NULL
`

type GetMessageByIDRow struct {
	ID              int64         `json:"id"`
	WorkspaceID     int64         `json:"workspace_id"`
	ChannelID       sql.NullInt64 `json:"channel_id"`
	SenderID        int64         `json:"sender_id"`
	ReceiverID      sql.NullInt64 `json:"receiver_id"`
	Content         string        `json:"content"`
	MessageType     string        `json:"message_type"`
	ThreadID        sql.NullInt64 `json:"thread_id"`
	EditedAt        sql.NullTime  `json:"edited_at"`
	DeletedAt       sql.NullTime  `json:"deleted_at"`
	CreatedAt       time.Time     `json:"created_at"`
	ContentType     string        `json:"content_type"`
	ReplyCount      int32         `json:"reply_count"`
	LastReplyAt     sql.NullTime  `json:"last_reply_at"`
	SenderFirstName string        `json:"sender_first_name"`
	SenderLastName  string        `json:"sender_last_name"`
	SenderEmail     string        `json:"sender_email"`
}

func (q *Queries) GetMessageByID(ctx context.Context, id int64) (GetMessageByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getMessageByID, id)
	var i GetMessageByIDRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ChannelID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Content,
		&i.MessageType,
		&i.ThreadID,
		&i.EditedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.ContentType,
		&i.ReplyCount,
		&i.LastReplyAt,
		&i.SenderFirstName,
		&i.SenderLastName,
		&i.SenderEmail,
	)
	return i, err
}

const getRecentWorkspaceMessages = `-- name: GetRecentWorkspaceMessages :many
SELECT 
    m.id, m.workspace_id, m.channel_id, m.sender_id, m.receiver_id, m.content, m.message_type, m.thread_id, m.edited_at, m.deleted_at, m.created_at, m.content_type, m.reply_count, m.last_reply_at,
    u.first_name as sender_first_name,
    u.last_name as sender_last_name,
    u.email as sender_email
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.workspace_id = $1 
    AND m.deleted_at IS NULL
ORDER BY m.created_at DESC
LIMIT $2
OFFSET $3
`

type GetRecentWorkspaceMessagesParams struct {
	WorkspaceID int64 `json:"workspace_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

type GetRecentWorkspaceMessagesRow struct {
	ID              int64         `json:"id"`
	WorkspaceID     int64         `json:"workspace_id"`
	ChannelID       sql.NullInt64 `json:"channel_id"`
	SenderID        int64         `json:"sender_id"`
	ReceiverID      sql.NullInt64 `json:"receiver_id"`
	Content         string        `json:"content"`
	MessageType     string        `json:"message_type"`
	ThreadID        sql.NullInt64 `json:"thread_id"`
	EditedAt        sql.NullTime  `json:"edited_at"`
	DeletedAt       sql.NullTime  `json:"deleted_at"`
	CreatedAt       time.Time     `json:"created_at"`
	ContentType     string        `json:"content_type"`
	ReplyCount      int32         `json:"reply_count"`
	LastReplyAt     sql.NullTime  `json:"last_reply_at"`
	SenderFirstName string        `json:"sender_first_name"`
	SenderLastName  string        `json:"sender_last_name"`
	SenderEmail     string        `json:"sender_email"`
}

func (q *Queries) GetRecentWorkspaceMessages(ctx context.Context, arg GetRecentWorkspaceMessagesParams) ([]GetRecentWorkspaceMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentWorkspaceMessages, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentWorkspaceMessagesRow{}
	for rows.Next() {
		var i GetRecentWorkspaceMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ChannelID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Content,
			&i.MessageType,
			&i.ThreadID,
			&i.EditedAt,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.ContentType,
			&i.ReplyCount,
			&i.LastReplyAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.SenderEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreadInfo = `-- name: GetThreadInfo :one
SELECT m.id, m.content, m.created_at, m.reply_count, m.last_reply_at,
       u.first_name, u.last_name
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.id = $1 AND m.deleted_at IS NULL
`

type GetThreadInfoRow struct {
	ID          int64        `json:"id"`
	Content     string       `json:"content"`
	CreatedAt   time.Time    `json:"created_at"`
	ReplyCount  int32        `json:"reply_count"`
	LastReplyAt sql.NullTime `json:"last_reply_at"`
	FirstName   string       `json:"first_name"`
	LastName    string       `json:"last_name"`
}

func (q *Queries) GetThreadInfo(ctx context.Context, id int64) (GetThreadInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getThreadInfo, id)
	var i GetThreadInfoRow
	err := row.Scan(
		&i.ID,
		&i.Content,
		&i.CreatedAt,
		&i.ReplyCount,
		&i.LastReplyAt,
		&i.FirstName,
		&i.LastName,
	)
	return i, err
}

const getThreadMessages = `-- name: GetThreadMessages :many
SELECT m.id, m.workspace_id, m.channel_id, m.sender_id, m.receiver_id, m.content, m.message_type, m.thread_id, m.edited_at, m.deleted_at, m.created_at, m.content_type, m.reply_count, m.last_reply_at, u.first_name, u.last_name
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE (m.id = $1 OR m.thread_id = $1) 
  AND m.deleted_at IS NULL
ORDER BY m.created_at ASC
`

type GetThreadMessagesRow struct {
	ID          int64         `json:"id"`
	WorkspaceID int64         `json:"workspace_id"`
	ChannelID   sql.NullInt64 `json:"channel_id"`
	SenderID    int64         `json:"sender_id"`
	ReceiverID  sql.NullInt64 `json:"receiver_id"`
	Content     string        `json:"content"`
	MessageType string        `json:"message_type"`
	ThreadID    sql.NullInt64 `json:"thread_id"`
	EditedAt    sql.NullTime  `json:"edited_at"`
	DeletedAt   sql.NullTime  `json:"deleted_at"`
	CreatedAt   time.Time     `json:"created_at"`
	ContentType string        `json:"content_type"`
	ReplyCount  int32         `json:"reply_count"`
	LastReplyAt sql.NullTime  `json:"last_reply_at"`
	FirstName   string        `json:"first_name"`
	LastName    string        `json:"last_name"`
}

func (q *Queries) GetThreadMessages(ctx context.Context, id int64) ([]GetThreadMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getThreadMessages, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetThreadMessagesRow{}
	for rows.Next() {
		var i GetThreadMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ChannelID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Content,
			&i.MessageType,
			&i.ThreadID,
			&i.EditedAt,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.ContentType,
			&i.ReplyCount,
			&i.LastReplyAt,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getThreadReplies = `-- name: GetThreadReplies :many
SELECT m.id, m.workspace_id, m.channel_id, m.sender_id, m.receiver_id, m.content, m.message_type, m.thread_id, m.edited_at, m.deleted_at, m.created_at, m.content_type, m.reply_count, m.last_reply_at, u.first_name, u.last_name
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.thread_id = $1 
  AND m.deleted_at IS NULL
ORDER BY m.created_at ASC
LIMIT $2 OFFSET $3
`

type GetThreadRepliesParams struct {
	ThreadID sql.NullInt64 `json:"thread_id"`
	Limit    int32         `json:"limit"`
	Offset   int32         `json:"offset"`
}

type GetThreadRepliesRow struct {
	ID          int64         `json:"id"`
	WorkspaceID int64         `json:"workspace_id"`
	ChannelID   sql.NullInt64 `json:"channel_id"`
	SenderID    int64         `json:"sender_id"`
	ReceiverID  sql.NullInt64 `json:"receiver_id"`
	Content     string        `json:"content"`
	MessageType string        `json:"message_type"`
	ThreadID    sql.NullInt64 `json:"thread_id"`
	EditedAt    sql.NullTime  `json:"edited_at"`
	DeletedAt   sql.NullTime  `json:"deleted_at"`
	CreatedAt   time.Time     `json:"created_at"`
	ContentType string        `json:"content_type"`
	ReplyCount  int32         `json:"reply_count"`
	LastReplyAt sql.NullTime  `json:"last_reply_at"`
	FirstName   string        `json:"first_name"`
	LastName    string        `json:"last_name"`
}

func (q *Queries) GetThreadReplies(ctx context.Context, arg GetThreadRepliesParams) ([]GetThreadRepliesRow, error) {
	rows, err := q.db.QueryContext(ctx, getThreadReplies, arg.ThreadID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetThreadRepliesRow{}
	for rows.Next() {
		var i GetThreadRepliesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ChannelID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Content,
			&i.MessageType,
			&i.ThreadID,
			&i.EditedAt,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.ContentType,
			&i.ReplyCount,
			&i.LastReplyAt,
			&i.FirstName,
			&i.LastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteMessage = `-- name: SoftDeleteMessage :exec
UPDATE messages
SET deleted_at = now()
WHERE id = $1
`

func (q *Queries) SoftDeleteMessage(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, softDeleteMessage, id)
	return err
}

const updateMessageContent = `-- name: UpdateMessageContent :one
UPDATE messages
SET 
    content = $2,
    edited_at = now()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, workspace_id, channel_id, sender_id, receiver_id, content, message_type, thread_id, edited_at, deleted_at, created_at, content_type, reply_count, last_reply_at
`

type UpdateMessageContentParams struct {
	ID      int64  `json:"id"`
	Content string `json:"content"`
}

func (q *Queries) UpdateMessageContent(ctx context.Context, arg UpdateMessageContentParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, updateMessageContent, arg.ID, arg.Content)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.ChannelID,
		&i.SenderID,
		&i.ReceiverID,
		&i.Content,
		&i.MessageType,
		&i.ThreadID,
		&i.EditedAt,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.ContentType,
		&i.ReplyCount,
		&i.LastReplyAt,
	)
	return i, err
}
