// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: pinned_messages.sql

package db

import (
	"context"
	"time"
)

const getPinnedMessages = `-- name: GetPinnedMessages :many
SELECT pm.id, pm.message_id, pm.channel_id, pm.pinned_by, pm.pinned_at, m.content, m.created_at as message_created_at,
       u.first_name as sender_first_name, u.last_name as sender_last_name,
       pu.first_name as pinned_by_first_name, pu.last_name as pinned_by_last_name
FROM pinned_messages pm
JOIN messages m ON pm.message_id = m.id
JOIN users u ON m.sender_id = u.id
JOIN users pu ON pm.pinned_by = pu.id
WHERE pm.channel_id = $1
ORDER BY pm.pinned_at DESC
`

type GetPinnedMessagesRow struct {
	ID                int64     `json:"id"`
	MessageID         int64     `json:"message_id"`
	ChannelID         int64     `json:"channel_id"`
	PinnedBy          int64     `json:"pinned_by"`
	PinnedAt          time.Time `json:"pinned_at"`
	Content           string    `json:"content"`
	MessageCreatedAt  time.Time `json:"message_created_at"`
	SenderFirstName   string    `json:"sender_first_name"`
	SenderLastName    string    `json:"sender_last_name"`
	PinnedByFirstName string    `json:"pinned_by_first_name"`
	PinnedByLastName  string    `json:"pinned_by_last_name"`
}

func (q *Queries) GetPinnedMessages(ctx context.Context, channelID int64) ([]GetPinnedMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getPinnedMessages, channelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPinnedMessagesRow{}
	for rows.Next() {
		var i GetPinnedMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.ChannelID,
			&i.PinnedBy,
			&i.PinnedAt,
			&i.Content,
			&i.MessageCreatedAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.PinnedByFirstName,
			&i.PinnedByLastName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isMessagePinned = `-- name: IsMessagePinned :one
SELECT EXISTS(
    SELECT 1 FROM pinned_messages WHERE message_id = $1
) as is_pinned
`

func (q *Queries) IsMessagePinned(ctx context.Context, messageID int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, isMessagePinned, messageID)
	var is_pinned bool
	err := row.Scan(&is_pinned)
	return is_pinned, err
}

const pinMessage = `-- name: PinMessage :one
INSERT INTO pinned_messages (message_id, channel_id, pinned_by)
VALUES ($1, $2, $3)
RETURNING id, message_id, channel_id, pinned_by, pinned_at
`

type PinMessageParams struct {
	MessageID int64 `json:"message_id"`
	ChannelID int64 `json:"channel_id"`
	PinnedBy  int64 `json:"pinned_by"`
}

func (q *Queries) PinMessage(ctx context.Context, arg PinMessageParams) (PinnedMessage, error) {
	row := q.db.QueryRowContext(ctx, pinMessage, arg.MessageID, arg.ChannelID, arg.PinnedBy)
	var i PinnedMessage
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.ChannelID,
		&i.PinnedBy,
		&i.PinnedAt,
	)
	return i, err
}

const unpinMessage = `-- name: UnpinMessage :exec
DELETE FROM pinned_messages WHERE message_id = $1
`

func (q *Queries) UnpinMessage(ctx context.Context, messageID int64) error {
	_, err := q.db.ExecContext(ctx, unpinMessage, messageID)
	return err
}
