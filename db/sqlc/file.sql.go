// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: file.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const checkFileAccess = `-- name: CheckFileAccess :one
SELECT CASE 
    WHEN f.uploader_id = $2 THEN true
    WHEN f.is_public = true THEN true
    WHEN EXISTS (
        SELECT 1 FROM file_shares fs 
        WHERE fs.file_id = $1 AND fs.shared_with_user_id = $2 
        AND (fs.expires_at IS NULL OR fs.expires_at > now())
    ) THEN true
    WHEN EXISTS (
        SELECT 1 FROM file_shares fs 
        JOIN channel_members cm ON fs.channel_id = cm.channel_id
        WHERE fs.file_id = $1 AND cm.user_id = $2
        AND (fs.expires_at IS NULL OR fs.expires_at > now())
    ) THEN true
    ELSE false
END as has_access
FROM files f
WHERE f.id = $1
`

type CheckFileAccessParams struct {
	FileID     int64 `json:"file_id"`
	UploaderID int64 `json:"uploader_id"`
}

// Check if user has access to file through direct ownership, channel membership, or direct share
func (q *Queries) CheckFileAccess(ctx context.Context, arg CheckFileAccessParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkFileAccess, arg.FileID, arg.UploaderID)
	var has_access bool
	err := row.Scan(&has_access)
	return has_access, err
}

const cleanupIncompleteUploads = `-- name: CleanupIncompleteUploads :exec
DELETE FROM files 
WHERE upload_completed = false 
AND created_at < now() - INTERVAL '1 hour'
`

func (q *Queries) CleanupIncompleteUploads(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupIncompleteUploads)
	return err
}

const createFile = `-- name: CreateFile :one
INSERT INTO files (
    workspace_id, uploader_id, original_filename, stored_filename, 
    file_path, file_size, mime_type, file_hash, is_public, 
    upload_completed, thumbnail_path
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, workspace_id, uploader_id, original_filename, stored_filename, file_path, file_size, mime_type, file_hash, is_public, upload_completed, thumbnail_path, created_at, updated_at
`

type CreateFileParams struct {
	WorkspaceID      int64          `json:"workspace_id"`
	UploaderID       int64          `json:"uploader_id"`
	OriginalFilename string         `json:"original_filename"`
	StoredFilename   string         `json:"stored_filename"`
	FilePath         string         `json:"file_path"`
	FileSize         int64          `json:"file_size"`
	MimeType         string         `json:"mime_type"`
	FileHash         string         `json:"file_hash"`
	IsPublic         bool           `json:"is_public"`
	UploadCompleted  bool           `json:"upload_completed"`
	ThumbnailPath    sql.NullString `json:"thumbnail_path"`
}

func (q *Queries) CreateFile(ctx context.Context, arg CreateFileParams) (File, error) {
	row := q.db.QueryRowContext(ctx, createFile,
		arg.WorkspaceID,
		arg.UploaderID,
		arg.OriginalFilename,
		arg.StoredFilename,
		arg.FilePath,
		arg.FileSize,
		arg.MimeType,
		arg.FileHash,
		arg.IsPublic,
		arg.UploadCompleted,
		arg.ThumbnailPath,
	)
	var i File
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.UploaderID,
		&i.OriginalFilename,
		&i.StoredFilename,
		&i.FilePath,
		&i.FileSize,
		&i.MimeType,
		&i.FileHash,
		&i.IsPublic,
		&i.UploadCompleted,
		&i.ThumbnailPath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFileShare = `-- name: CreateFileShare :one
INSERT INTO file_shares (file_id, shared_by, channel_id, shared_with_user_id, permission, expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, file_id, shared_by, channel_id, shared_with_user_id, permission, expires_at, created_at
`

type CreateFileShareParams struct {
	FileID           int64         `json:"file_id"`
	SharedBy         int64         `json:"shared_by"`
	ChannelID        sql.NullInt64 `json:"channel_id"`
	SharedWithUserID sql.NullInt64 `json:"shared_with_user_id"`
	Permission       string        `json:"permission"`
	ExpiresAt        sql.NullTime  `json:"expires_at"`
}

func (q *Queries) CreateFileShare(ctx context.Context, arg CreateFileShareParams) (FileShare, error) {
	row := q.db.QueryRowContext(ctx, createFileShare,
		arg.FileID,
		arg.SharedBy,
		arg.ChannelID,
		arg.SharedWithUserID,
		arg.Permission,
		arg.ExpiresAt,
	)
	var i FileShare
	err := row.Scan(
		&i.ID,
		&i.FileID,
		&i.SharedBy,
		&i.ChannelID,
		&i.SharedWithUserID,
		&i.Permission,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createMessageFile = `-- name: CreateMessageFile :one
INSERT INTO message_files (message_id, file_id)
VALUES ($1, $2)
RETURNING id, message_id, file_id, created_at
`

type CreateMessageFileParams struct {
	MessageID int64 `json:"message_id"`
	FileID    int64 `json:"file_id"`
}

func (q *Queries) CreateMessageFile(ctx context.Context, arg CreateMessageFileParams) (MessageFile, error) {
	row := q.db.QueryRowContext(ctx, createMessageFile, arg.MessageID, arg.FileID)
	var i MessageFile
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.FileID,
		&i.CreatedAt,
	)
	return i, err
}

const deleteFile = `-- name: DeleteFile :exec
DELETE FROM files
WHERE id = $1 AND uploader_id = $2
`

type DeleteFileParams struct {
	ID         int64 `json:"id"`
	UploaderID int64 `json:"uploader_id"`
}

func (q *Queries) DeleteFile(ctx context.Context, arg DeleteFileParams) error {
	_, err := q.db.ExecContext(ctx, deleteFile, arg.ID, arg.UploaderID)
	return err
}

const deleteMessageFile = `-- name: DeleteMessageFile :exec
DELETE FROM message_files
WHERE message_id = $1 AND file_id = $2
`

type DeleteMessageFileParams struct {
	MessageID int64 `json:"message_id"`
	FileID    int64 `json:"file_id"`
}

func (q *Queries) DeleteMessageFile(ctx context.Context, arg DeleteMessageFileParams) error {
	_, err := q.db.ExecContext(ctx, deleteMessageFile, arg.MessageID, arg.FileID)
	return err
}

const getDuplicateFiles = `-- name: GetDuplicateFiles :many
SELECT file_hash, COUNT(*) as count, ARRAY_AGG(id) as file_ids, SUM(file_size) as total_size
FROM files 
WHERE workspace_id = $1 AND upload_completed = true
GROUP BY file_hash 
HAVING COUNT(*) > 1
ORDER BY count DESC
`

type GetDuplicateFilesRow struct {
	FileHash  string      `json:"file_hash"`
	Count     int64       `json:"count"`
	FileIds   interface{} `json:"file_ids"`
	TotalSize int64       `json:"total_size"`
}

func (q *Queries) GetDuplicateFiles(ctx context.Context, workspaceID int64) ([]GetDuplicateFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, getDuplicateFiles, workspaceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDuplicateFilesRow{}
	for rows.Next() {
		var i GetDuplicateFilesRow
		if err := rows.Scan(
			&i.FileHash,
			&i.Count,
			&i.FileIds,
			&i.TotalSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFile = `-- name: GetFile :one
SELECT id, workspace_id, uploader_id, original_filename, stored_filename, file_path, file_size, mime_type, file_hash, is_public, upload_completed, thumbnail_path, created_at, updated_at FROM files
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetFile(ctx context.Context, id int64) (File, error) {
	row := q.db.QueryRowContext(ctx, getFile, id)
	var i File
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.UploaderID,
		&i.OriginalFilename,
		&i.StoredFilename,
		&i.FilePath,
		&i.FileSize,
		&i.MimeType,
		&i.FileHash,
		&i.IsPublic,
		&i.UploadCompleted,
		&i.ThumbnailPath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileByHash = `-- name: GetFileByHash :one
SELECT id, workspace_id, uploader_id, original_filename, stored_filename, file_path, file_size, mime_type, file_hash, is_public, upload_completed, thumbnail_path, created_at, updated_at FROM files
WHERE file_hash = $1 AND workspace_id = $2 AND upload_completed = true
LIMIT 1
`

type GetFileByHashParams struct {
	FileHash    string `json:"file_hash"`
	WorkspaceID int64  `json:"workspace_id"`
}

func (q *Queries) GetFileByHash(ctx context.Context, arg GetFileByHashParams) (File, error) {
	row := q.db.QueryRowContext(ctx, getFileByHash, arg.FileHash, arg.WorkspaceID)
	var i File
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.UploaderID,
		&i.OriginalFilename,
		&i.StoredFilename,
		&i.FilePath,
		&i.FileSize,
		&i.MimeType,
		&i.FileHash,
		&i.IsPublic,
		&i.UploadCompleted,
		&i.ThumbnailPath,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFileMessages = `-- name: GetFileMessages :many
SELECT m.id, m.workspace_id, m.channel_id, m.sender_id, m.receiver_id, m.content, m.message_type, m.thread_id, m.edited_at, m.deleted_at, m.created_at, m.content_type, u.first_name as sender_first_name, u.last_name as sender_last_name, u.email as sender_email
FROM message_files mf
JOIN messages m ON mf.message_id = m.id
JOIN users u ON m.sender_id = u.id
WHERE mf.file_id = $1 AND m.deleted_at IS NULL
ORDER BY m.created_at DESC
`

type GetFileMessagesRow struct {
	ID              int64         `json:"id"`
	WorkspaceID     int64         `json:"workspace_id"`
	ChannelID       sql.NullInt64 `json:"channel_id"`
	SenderID        int64         `json:"sender_id"`
	ReceiverID      sql.NullInt64 `json:"receiver_id"`
	Content         string        `json:"content"`
	MessageType     string        `json:"message_type"`
	ThreadID        sql.NullInt64 `json:"thread_id"`
	EditedAt        sql.NullTime  `json:"edited_at"`
	DeletedAt       sql.NullTime  `json:"deleted_at"`
	CreatedAt       time.Time     `json:"created_at"`
	ContentType     string        `json:"content_type"`
	SenderFirstName string        `json:"sender_first_name"`
	SenderLastName  string        `json:"sender_last_name"`
	SenderEmail     string        `json:"sender_email"`
}

func (q *Queries) GetFileMessages(ctx context.Context, fileID int64) ([]GetFileMessagesRow, error) {
	rows, err := q.db.QueryContext(ctx, getFileMessages, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFileMessagesRow{}
	for rows.Next() {
		var i GetFileMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.ChannelID,
			&i.SenderID,
			&i.ReceiverID,
			&i.Content,
			&i.MessageType,
			&i.ThreadID,
			&i.EditedAt,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.ContentType,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.SenderEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileShares = `-- name: GetFileShares :many
SELECT fs.id, fs.file_id, fs.shared_by, fs.channel_id, fs.shared_with_user_id, fs.permission, fs.expires_at, fs.created_at, u.first_name as shared_by_first_name, u.last_name as shared_by_last_name, u.email as shared_by_email
FROM file_shares fs
JOIN users u ON fs.shared_by = u.id
WHERE fs.file_id = $1
ORDER BY fs.created_at DESC
`

type GetFileSharesRow struct {
	ID                int64         `json:"id"`
	FileID            int64         `json:"file_id"`
	SharedBy          int64         `json:"shared_by"`
	ChannelID         sql.NullInt64 `json:"channel_id"`
	SharedWithUserID  sql.NullInt64 `json:"shared_with_user_id"`
	Permission        string        `json:"permission"`
	ExpiresAt         sql.NullTime  `json:"expires_at"`
	CreatedAt         time.Time     `json:"created_at"`
	SharedByFirstName string        `json:"shared_by_first_name"`
	SharedByLastName  string        `json:"shared_by_last_name"`
	SharedByEmail     string        `json:"shared_by_email"`
}

func (q *Queries) GetFileShares(ctx context.Context, fileID int64) ([]GetFileSharesRow, error) {
	rows, err := q.db.QueryContext(ctx, getFileShares, fileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFileSharesRow{}
	for rows.Next() {
		var i GetFileSharesRow
		if err := rows.Scan(
			&i.ID,
			&i.FileID,
			&i.SharedBy,
			&i.ChannelID,
			&i.SharedWithUserID,
			&i.Permission,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.SharedByFirstName,
			&i.SharedByLastName,
			&i.SharedByEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFileStats = `-- name: GetFileStats :one
SELECT 
    COUNT(*) as total_files,
    COALESCE(SUM(file_size), 0) as total_size,
    COUNT(*) FILTER (WHERE mime_type LIKE 'image/%') as image_count,
    COUNT(*) FILTER (WHERE mime_type = 'application/pdf') as pdf_count
FROM files 
WHERE workspace_id = $1 AND upload_completed = true
`

type GetFileStatsRow struct {
	TotalFiles int64       `json:"total_files"`
	TotalSize  interface{} `json:"total_size"`
	ImageCount int64       `json:"image_count"`
	PdfCount   int64       `json:"pdf_count"`
}

func (q *Queries) GetFileStats(ctx context.Context, workspaceID int64) (GetFileStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getFileStats, workspaceID)
	var i GetFileStatsRow
	err := row.Scan(
		&i.TotalFiles,
		&i.TotalSize,
		&i.ImageCount,
		&i.PdfCount,
	)
	return i, err
}

const getFileWithPermissionCheck = `-- name: GetFileWithPermissionCheck :one
SELECT f.id, f.workspace_id, f.uploader_id, f.original_filename, f.stored_filename, f.file_path, f.file_size, f.mime_type, f.file_hash, f.is_public, f.upload_completed, f.thumbnail_path, f.created_at, f.updated_at, u.first_name as uploader_first_name, u.last_name as uploader_last_name, u.email as uploader_email
FROM files f
JOIN users u ON f.uploader_id = u.id
WHERE f.id = $1 AND f.workspace_id = $2 AND f.upload_completed = true
LIMIT 1
`

type GetFileWithPermissionCheckParams struct {
	ID          int64 `json:"id"`
	WorkspaceID int64 `json:"workspace_id"`
}

type GetFileWithPermissionCheckRow struct {
	ID                int64          `json:"id"`
	WorkspaceID       int64          `json:"workspace_id"`
	UploaderID        int64          `json:"uploader_id"`
	OriginalFilename  string         `json:"original_filename"`
	StoredFilename    string         `json:"stored_filename"`
	FilePath          string         `json:"file_path"`
	FileSize          int64          `json:"file_size"`
	MimeType          string         `json:"mime_type"`
	FileHash          string         `json:"file_hash"`
	IsPublic          bool           `json:"is_public"`
	UploadCompleted   bool           `json:"upload_completed"`
	ThumbnailPath     sql.NullString `json:"thumbnail_path"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	UploaderFirstName string         `json:"uploader_first_name"`
	UploaderLastName  string         `json:"uploader_last_name"`
	UploaderEmail     string         `json:"uploader_email"`
}

func (q *Queries) GetFileWithPermissionCheck(ctx context.Context, arg GetFileWithPermissionCheckParams) (GetFileWithPermissionCheckRow, error) {
	row := q.db.QueryRowContext(ctx, getFileWithPermissionCheck, arg.ID, arg.WorkspaceID)
	var i GetFileWithPermissionCheckRow
	err := row.Scan(
		&i.ID,
		&i.WorkspaceID,
		&i.UploaderID,
		&i.OriginalFilename,
		&i.StoredFilename,
		&i.FilePath,
		&i.FileSize,
		&i.MimeType,
		&i.FileHash,
		&i.IsPublic,
		&i.UploadCompleted,
		&i.ThumbnailPath,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UploaderFirstName,
		&i.UploaderLastName,
		&i.UploaderEmail,
	)
	return i, err
}

const getMessageFiles = `-- name: GetMessageFiles :many
SELECT f.id, f.workspace_id, f.uploader_id, f.original_filename, f.stored_filename, f.file_path, f.file_size, f.mime_type, f.file_hash, f.is_public, f.upload_completed, f.thumbnail_path, f.created_at, f.updated_at, u.first_name as uploader_first_name, u.last_name as uploader_last_name, u.email as uploader_email
FROM message_files mf
JOIN files f ON mf.file_id = f.id
JOIN users u ON f.uploader_id = u.id
WHERE mf.message_id = $1
ORDER BY mf.created_at ASC
`

type GetMessageFilesRow struct {
	ID                int64          `json:"id"`
	WorkspaceID       int64          `json:"workspace_id"`
	UploaderID        int64          `json:"uploader_id"`
	OriginalFilename  string         `json:"original_filename"`
	StoredFilename    string         `json:"stored_filename"`
	FilePath          string         `json:"file_path"`
	FileSize          int64          `json:"file_size"`
	MimeType          string         `json:"mime_type"`
	FileHash          string         `json:"file_hash"`
	IsPublic          bool           `json:"is_public"`
	UploadCompleted   bool           `json:"upload_completed"`
	ThumbnailPath     sql.NullString `json:"thumbnail_path"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	UploaderFirstName string         `json:"uploader_first_name"`
	UploaderLastName  string         `json:"uploader_last_name"`
	UploaderEmail     string         `json:"uploader_email"`
}

func (q *Queries) GetMessageFiles(ctx context.Context, messageID int64) ([]GetMessageFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, getMessageFiles, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessageFilesRow{}
	for rows.Next() {
		var i GetMessageFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.UploaderID,
			&i.OriginalFilename,
			&i.StoredFilename,
			&i.FilePath,
			&i.FileSize,
			&i.MimeType,
			&i.FileHash,
			&i.IsPublic,
			&i.UploadCompleted,
			&i.ThumbnailPath,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UploaderFirstName,
			&i.UploaderLastName,
			&i.UploaderEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserFiles = `-- name: ListUserFiles :many
SELECT f.id, f.workspace_id, f.uploader_id, f.original_filename, f.stored_filename, f.file_path, f.file_size, f.mime_type, f.file_hash, f.is_public, f.upload_completed, f.thumbnail_path, f.created_at, f.updated_at, u.first_name as uploader_first_name, u.last_name as uploader_last_name, u.email as uploader_email
FROM files f
JOIN users u ON f.uploader_id = u.id
WHERE f.uploader_id = $1 AND f.workspace_id = $2 AND f.upload_completed = true
ORDER BY f.created_at DESC
LIMIT $3 OFFSET $4
`

type ListUserFilesParams struct {
	UploaderID  int64 `json:"uploader_id"`
	WorkspaceID int64 `json:"workspace_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

type ListUserFilesRow struct {
	ID                int64          `json:"id"`
	WorkspaceID       int64          `json:"workspace_id"`
	UploaderID        int64          `json:"uploader_id"`
	OriginalFilename  string         `json:"original_filename"`
	StoredFilename    string         `json:"stored_filename"`
	FilePath          string         `json:"file_path"`
	FileSize          int64          `json:"file_size"`
	MimeType          string         `json:"mime_type"`
	FileHash          string         `json:"file_hash"`
	IsPublic          bool           `json:"is_public"`
	UploadCompleted   bool           `json:"upload_completed"`
	ThumbnailPath     sql.NullString `json:"thumbnail_path"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	UploaderFirstName string         `json:"uploader_first_name"`
	UploaderLastName  string         `json:"uploader_last_name"`
	UploaderEmail     string         `json:"uploader_email"`
}

func (q *Queries) ListUserFiles(ctx context.Context, arg ListUserFilesParams) ([]ListUserFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserFiles,
		arg.UploaderID,
		arg.WorkspaceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserFilesRow{}
	for rows.Next() {
		var i ListUserFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.UploaderID,
			&i.OriginalFilename,
			&i.StoredFilename,
			&i.FilePath,
			&i.FileSize,
			&i.MimeType,
			&i.FileHash,
			&i.IsPublic,
			&i.UploadCompleted,
			&i.ThumbnailPath,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UploaderFirstName,
			&i.UploaderLastName,
			&i.UploaderEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkspaceFiles = `-- name: ListWorkspaceFiles :many
SELECT f.id, f.workspace_id, f.uploader_id, f.original_filename, f.stored_filename, f.file_path, f.file_size, f.mime_type, f.file_hash, f.is_public, f.upload_completed, f.thumbnail_path, f.created_at, f.updated_at, u.first_name as uploader_first_name, u.last_name as uploader_last_name, u.email as uploader_email
FROM files f
JOIN users u ON f.uploader_id = u.id
WHERE f.workspace_id = $1 AND f.upload_completed = true
ORDER BY f.created_at DESC
LIMIT $2 OFFSET $3
`

type ListWorkspaceFilesParams struct {
	WorkspaceID int64 `json:"workspace_id"`
	Limit       int32 `json:"limit"`
	Offset      int32 `json:"offset"`
}

type ListWorkspaceFilesRow struct {
	ID                int64          `json:"id"`
	WorkspaceID       int64          `json:"workspace_id"`
	UploaderID        int64          `json:"uploader_id"`
	OriginalFilename  string         `json:"original_filename"`
	StoredFilename    string         `json:"stored_filename"`
	FilePath          string         `json:"file_path"`
	FileSize          int64          `json:"file_size"`
	MimeType          string         `json:"mime_type"`
	FileHash          string         `json:"file_hash"`
	IsPublic          bool           `json:"is_public"`
	UploadCompleted   bool           `json:"upload_completed"`
	ThumbnailPath     sql.NullString `json:"thumbnail_path"`
	CreatedAt         time.Time      `json:"created_at"`
	UpdatedAt         time.Time      `json:"updated_at"`
	UploaderFirstName string         `json:"uploader_first_name"`
	UploaderLastName  string         `json:"uploader_last_name"`
	UploaderEmail     string         `json:"uploader_email"`
}

func (q *Queries) ListWorkspaceFiles(ctx context.Context, arg ListWorkspaceFilesParams) ([]ListWorkspaceFilesRow, error) {
	rows, err := q.db.QueryContext(ctx, listWorkspaceFiles, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListWorkspaceFilesRow{}
	for rows.Next() {
		var i ListWorkspaceFilesRow
		if err := rows.Scan(
			&i.ID,
			&i.WorkspaceID,
			&i.UploaderID,
			&i.OriginalFilename,
			&i.StoredFilename,
			&i.FilePath,
			&i.FileSize,
			&i.MimeType,
			&i.FileHash,
			&i.IsPublic,
			&i.UploadCompleted,
			&i.ThumbnailPath,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UploaderFirstName,
			&i.UploaderLastName,
			&i.UploaderEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFileThumbnail = `-- name: UpdateFileThumbnail :exec
UPDATE files
SET thumbnail_path = $2, updated_at = now()
WHERE id = $1
`

type UpdateFileThumbnailParams struct {
	ID            int64          `json:"id"`
	ThumbnailPath sql.NullString `json:"thumbnail_path"`
}

func (q *Queries) UpdateFileThumbnail(ctx context.Context, arg UpdateFileThumbnailParams) error {
	_, err := q.db.ExecContext(ctx, updateFileThumbnail, arg.ID, arg.ThumbnailPath)
	return err
}

const updateFileUploadStatus = `-- name: UpdateFileUploadStatus :exec
UPDATE files
SET upload_completed = $2, updated_at = now()
WHERE id = $1
`

type UpdateFileUploadStatusParams struct {
	ID              int64 `json:"id"`
	UploadCompleted bool  `json:"upload_completed"`
}

func (q *Queries) UpdateFileUploadStatus(ctx context.Context, arg UpdateFileUploadStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateFileUploadStatus, arg.ID, arg.UploadCompleted)
	return err
}
