// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: message_mentions.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createMessageMention = `-- name: CreateMessageMention :one
INSERT INTO message_mentions (message_id, mentioned_user_id, mention_type)
VALUES ($1, $2, $3)
RETURNING id, message_id, mentioned_user_id, mention_type, created_at
`

type CreateMessageMentionParams struct {
	MessageID       int64         `json:"message_id"`
	MentionedUserID sql.NullInt64 `json:"mentioned_user_id"`
	MentionType     string        `json:"mention_type"`
}

func (q *Queries) CreateMessageMention(ctx context.Context, arg CreateMessageMentionParams) (MessageMention, error) {
	row := q.db.QueryRowContext(ctx, createMessageMention, arg.MessageID, arg.MentionedUserID, arg.MentionType)
	var i MessageMention
	err := row.Scan(
		&i.ID,
		&i.MessageID,
		&i.MentionedUserID,
		&i.MentionType,
		&i.CreatedAt,
	)
	return i, err
}

const getMessageMentions = `-- name: GetMessageMentions :many
SELECT mm.id, mm.message_id, mm.mentioned_user_id, mm.mention_type, mm.created_at, u.first_name, u.last_name, u.email
FROM message_mentions mm
LEFT JOIN users u ON mm.mentioned_user_id = u.id
WHERE mm.message_id = $1
ORDER BY mm.created_at ASC
`

type GetMessageMentionsRow struct {
	ID              int64          `json:"id"`
	MessageID       int64          `json:"message_id"`
	MentionedUserID sql.NullInt64  `json:"mentioned_user_id"`
	MentionType     string         `json:"mention_type"`
	CreatedAt       time.Time      `json:"created_at"`
	FirstName       sql.NullString `json:"first_name"`
	LastName        sql.NullString `json:"last_name"`
	Email           sql.NullString `json:"email"`
}

func (q *Queries) GetMessageMentions(ctx context.Context, messageID int64) ([]GetMessageMentionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMessageMentions, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessageMentionsRow{}
	for rows.Next() {
		var i GetMessageMentionsRow
		if err := rows.Scan(
			&i.ID,
			&i.MessageID,
			&i.MentionedUserID,
			&i.MentionType,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnreadMentions = `-- name: GetUnreadMentions :many
SELECT mm.message_id, mm.mention_type, mm.created_at,
       m.content, m.created_at as message_created_at,
       u.first_name as sender_first_name, u.last_name as sender_last_name,
       c.name as channel_name
FROM message_mentions mm
JOIN messages m ON mm.message_id = m.id
JOIN users u ON m.sender_id = u.id
LEFT JOIN channels c ON m.channel_id = c.id
LEFT JOIN unread_messages um ON (
    (m.channel_id IS NOT NULL AND um.channel_id = m.channel_id AND um.user_id = $1) OR
    (m.receiver_id = $1 AND um.channel_id IS NULL AND um.user_id = $1)
)
WHERE (mm.mentioned_user_id = $1 OR (mm.mention_type IN ('channel', 'here', 'everyone') AND m.workspace_id = $2))
  AND (um.last_read_message_id IS NULL OR m.id > um.last_read_message_id)
ORDER BY mm.created_at DESC
LIMIT $3
`

type GetUnreadMentionsParams struct {
	UserID      int64 `json:"user_id"`
	WorkspaceID int64 `json:"workspace_id"`
	Limit       int32 `json:"limit"`
}

type GetUnreadMentionsRow struct {
	MessageID        int64          `json:"message_id"`
	MentionType      string         `json:"mention_type"`
	CreatedAt        time.Time      `json:"created_at"`
	Content          string         `json:"content"`
	MessageCreatedAt time.Time      `json:"message_created_at"`
	SenderFirstName  string         `json:"sender_first_name"`
	SenderLastName   string         `json:"sender_last_name"`
	ChannelName      sql.NullString `json:"channel_name"`
}

func (q *Queries) GetUnreadMentions(ctx context.Context, arg GetUnreadMentionsParams) ([]GetUnreadMentionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnreadMentions, arg.UserID, arg.WorkspaceID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnreadMentionsRow{}
	for rows.Next() {
		var i GetUnreadMentionsRow
		if err := rows.Scan(
			&i.MessageID,
			&i.MentionType,
			&i.CreatedAt,
			&i.Content,
			&i.MessageCreatedAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.ChannelName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserMentions = `-- name: GetUserMentions :many
SELECT mm.message_id, mm.mention_type, mm.created_at,
       m.content, m.created_at as message_created_at,
       u.first_name as sender_first_name, u.last_name as sender_last_name,
       c.name as channel_name
FROM message_mentions mm
JOIN messages m ON mm.message_id = m.id
JOIN users u ON m.sender_id = u.id
LEFT JOIN channels c ON m.channel_id = c.id
WHERE mm.mentioned_user_id = $1 
   OR (mm.mention_type IN ('channel', 'here', 'everyone') AND m.workspace_id = $2)
ORDER BY mm.created_at DESC
LIMIT $3 OFFSET $4
`

type GetUserMentionsParams struct {
	MentionedUserID sql.NullInt64 `json:"mentioned_user_id"`
	WorkspaceID     int64         `json:"workspace_id"`
	Limit           int32         `json:"limit"`
	Offset          int32         `json:"offset"`
}

type GetUserMentionsRow struct {
	MessageID        int64          `json:"message_id"`
	MentionType      string         `json:"mention_type"`
	CreatedAt        time.Time      `json:"created_at"`
	Content          string         `json:"content"`
	MessageCreatedAt time.Time      `json:"message_created_at"`
	SenderFirstName  string         `json:"sender_first_name"`
	SenderLastName   string         `json:"sender_last_name"`
	ChannelName      sql.NullString `json:"channel_name"`
}

func (q *Queries) GetUserMentions(ctx context.Context, arg GetUserMentionsParams) ([]GetUserMentionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserMentions,
		arg.MentionedUserID,
		arg.WorkspaceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserMentionsRow{}
	for rows.Next() {
		var i GetUserMentionsRow
		if err := rows.Scan(
			&i.MessageID,
			&i.MentionType,
			&i.CreatedAt,
			&i.Content,
			&i.MessageCreatedAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.ChannelName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
